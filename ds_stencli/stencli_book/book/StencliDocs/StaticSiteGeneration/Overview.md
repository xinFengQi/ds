# 使用Stencli生成静态网页

快速构建交互式网站和web应用程序的最佳方法之一是利用静态网页生成而不是服务器渲染(SSR)或客户端渲染(SPA，单页面应用)。


静态站点生成(SSG)意味着在构建时(也称预渲染)而不是在服务器请求时(SSR)或客户端运行时(SPA)构建和渲染组件和路由。由路由已经预先呈现，因此该路由得所有内容都可立即用于搜索引擎和客户端，因此SEO和性能得以最大化。

静态网站生成并不意味着您的页面必须是静态的或保持静态！Stencil利用水合作用在运行时有效地加载客户端组件，以充分利用两者的优势。

有关此示例的示例，可以使用Chrome浏览器打开此页面，在页面上单击鼠标右键，然后单击“查看网页源代码”选项。您会注意到，此页面不需要任何外部JavaScript或CSS文件作为第一个绘画。

由于“静态网站生成”会预渲染组件，因此需要记住一些折中和注意事项，但是大多数组件可以轻松进行预渲染，而无需进行大量修改。

Stencil使SSG变得容易，因此请继续阅读以了解如何将其整合到您的应用程序中。

静态站点生成得好处

1. 高的[Lighthouse](https://developers.google.com/web/tools/lighthouse/)评分
2. 最快的[加载速度](https://web.dev/lcp/)(LCP)
3. 更好的搜索引擎优化（SEO）
4. 为禁用了JavaScript的用户提供功能

## 静态网站生成和预渲染工作方式

构建Hydrate应用程序： 预渲染的第一步是让编译器生成一个“ hydrate”应用程序，该应用程序是Node.js使用的单个目录。--prerender提供CLI标志后，系统会自动生成“水合物”应用程序，默认情况下，该应用程序保存到dist/hydrate。预渲染在内部使用hydrate应用程序，但是可以在较低级别直接使用。了解有关Hydrate App的更多信息。

将预渲染任务分配到可用的CPU：Stencil可以使用Node.js的子进程API有效地将预渲染任务划分给当前计算机的每个CPU 。通过给计算机上的每个CPU执行分配任务，编译器可以大大加快预渲染时间。

Prerender Index：在编译器完成构建并在每个可用CPU上创建子进程之后，它将通过从单个基本URL或已配置的URL清单开始预渲染。页面完成预渲染后，它就会被作为index.html文件写到已配置的www目录中。

抓取应用程序：在每个页面预渲染期间，Stencil还将收集页面内使用的锚点元素和URL。有了这些信息，就可以通知主线程接下来应预渲染哪些页面。主线程负责协调所有URL，并且在所有页面都已被爬取和预呈现后，该工作就完成了。

将静态文件部署到生产环境中:现在所有的页面都已预先渲染并编写为静态HTML文件，www目录现在可以部署到服务器上了。预呈现和服务器端呈现(SSR)的一个显著区别是，HTTP服务器只提供静态HTML文件，而不是在服务器上动态生成HTML。

静态HTML响应：将静态HTML文件部署到服务器后，每个预渲染页面的访问者首先会收到具有内联样式且没有阻塞JS或CSS的HTML。此外，编译器已经知道访问者需要该页面的确切模块，并将使用linkmodulepreload异步预加载模块。

客户端水合：HTML和内联样式完成第一次绘制后，下一步是让客户端JavaScript对DOM中的相同节点进行水合。页面中的每个组件将按照在DOM结构中发现的初始顺序异步进行水合。接下来，当每个组件惰性加载时，它们便能够重用DOM中的现有节点。

## 工具

需要明确的是，Stencli也不会使用Puppeteer或jsdom预渲染。Puppeteer非常适合端到端测试，但是由于性能原因，快速生成包含数百或数千个页面的大型网站并不理想。此外，jsdom通常用于单元测试，但是根据我们的经验，很难与异步组件及其全局环境一起使用。

取而代之的是，Stencil使用自己的内部DOM API，这些API严格遵循Web标准，但针对预渲染，静态站点生成和服务器端渲染进行了优化。这样，开发人员仍然可以使用他们已经熟悉的所有相同的API，但是它们似乎也将在NodeJS环境中工作。这意味着开发人员在构建组件的过程中通常不必写不同的代码，而只专注于编写一种类型的组件，并使用他们已经知道的标准对其进行编码。重申一下，开发人员不必学习用于预渲染的新API。这是您的组件已经使用了相同的Web API。

每个组件，机器和环境的性能都会有所不同，因此很难提供一致的基准。但是，我们所知道的是Ionic的Documentation网站有数百页，Stencil可以在几秒钟内呈现整个网站。


