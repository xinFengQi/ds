# ts学习

因为目前需要一些知识充实架构基础，所以想把ts重新梳理一遍，然后去设计一套架构思想;以下都是来自于[官方文档](https://www.tslang.cn/docs/handbook/basic-types.html)

## 基础类型

1. 布尔值
2. 数值
3. 字符串
4. 数组

```
1. 普通数组: let list: number[] = [1, 2, 3];
2. 泛型数组: let list: Array<number> = [1, 2, 3];
```

5. 元组: 表示一个已知元素数量和类型的数组，各元素的类型不必相同。
6. 枚举:
7. Any
8. Void
9. Null和Undefined
10. Never
11. Object: object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。

### 类型断言
1. “尖括号”语法
2. as语法

## 类型声明
1. let
2. const

### 解构
#### 数组结构
1. 在数组里使用...语法创建剩余变量

#### 对象结构
1. 在对象里使用...语法创建剩余变量：

### 属性重命名

```
let { a: newName1, b: newName2 } = o;

指定解构类型: let {a, b}: {a: string, b: number} = o;
```

### 默认值
默认值可以让你在属性为 undefined 时使用缺省值：

### 函数声明

### 展开
展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。

1. 浅拷贝
2. 它仅包含对象自身的可枚举属性。 当你展开一个对象实例时，你会丢失其方法：


## 接口

###  可选属性

###  只读属性
通过赋值一个对象字面量来构造
1. ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改;可以用类型断言重写
2. 添加一个字符串索引签名

```
interface SquareConfig {
    [propName: string]: any;
}
```

### 函数类型

```
interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

1. 函数的参数名不需要与接口里定义的名字相匹配

### 可索引类型
1. 支持两种索引签名：字符串和数字
2. 数字索引的返回值必须是字符串索引返回值类型的子类型。

```
interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
```

3. 索引签名设置为只读，这样就防止了给索引赋值

### 类类型

1. 强制一个类去符合某种契约
2. 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。

### 类静态部分与实例部分

### 继承接口

1. 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里
2. 一个接口可以继承多个接口

### 混合类型

### 接口继承类

1. 当接口继承了一个类类型时，它会继承类的成员但不包括其实现
2. 当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现
3. 用处：指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系

## 类

### 继承
1. 派生类包含了一个构造函数，它必须调用super()
2. 在构造函数里访问this的属性之前，我们一定要调用super()

### 公共，私有与受保护的修饰符
1. private时，它就不能在声明它的类的外部访问
2. protected成员在派生类中仍然可以访问
3. 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承

### readonly修饰符
1. readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化

### 参数属性
1.  参数属性可以方便地让我们在一个地方定义并初始化一个成员。

### 存取器
支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。
1. 编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3
2. 只带有get不带有set的存取器自动被推断为readonly

### 静态属性
1. 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。

### 抽象类
1. 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化
2. 抽象类可以包含成员的实现细节
3. abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法
4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现

### 构造函数

### 把类当做接口使用

## 函数

### 类型
1. 函数的类型只是由参数类型和返回值组成的

### 推断类型
1.  按上下文归类

### 可选参数和默认参数
1. 在参数名旁使用?实现可选参数的功能

### 剩余参数
1. 在JavaScript里，你可以使用 arguments来访问所有传入的参数。
2. 在TypeScript里，你可以把所有参数收集到一个变量里：

```
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}
```

### this
1. JavaScript里，this的值在函数被调用的时候才会指定
2. 箭头函数能保存函数创建时的 this值，而不是调用时的值

#### this参数在回调函数里
1. 库函数的作者要指定 this的类型......

#### 重载