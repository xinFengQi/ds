# ts 学习

因为目前需要一些知识充实架构基础，所以想把 ts 重新梳理一遍，然后去设计一套架构思想;以下都是来自于[官方文档](https://www.tslang.cn/docs/handbook/basic-types.html)

## 基础类型

1. 布尔值
2. 数值
3. 字符串
4. 数组

```
1. 普通数组: let list: number[] = [1, 2, 3];
2. 泛型数组: let list: Array<number> = [1, 2, 3];
```

5. 元组: 表示一个已知元素数量和类型的数组，各元素的类型不必相同。
6. 枚举:
7. Any
8. Void
9. Null 和 Undefined
10. Never
11. Object: object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。

### 类型断言

1. “尖括号”语法
2. as 语法

## 类型声明

1. let
2. const

### 解构

#### 数组结构

1. 在数组里使用...语法创建剩余变量

#### 对象结构

1. 在对象里使用...语法创建剩余变量：

### 属性重命名

```
let { a: newName1, b: newName2 } = o;

指定解构类型: let {a, b}: {a: string, b: number} = o;
```

### 默认值

默认值可以让你在属性为 undefined 时使用缺省值：

### 函数声明

### 展开

展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。

1. 浅拷贝
2. 它仅包含对象自身的可枚举属性。 当你展开一个对象实例时，你会丢失其方法：

## 接口

### 可选属性

### 只读属性

通过赋值一个对象字面量来构造

1. ReadonlyArray<T>类型，它与 Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改;可以用类型断言重写
2. 添加一个字符串索引签名

```
interface SquareConfig {
    [propName: string]: any;
}
```

### 函数类型

```
interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

1. 函数的参数名不需要与接口里定义的名字相匹配

### 可索引类型

1. 支持两种索引签名：字符串和数字
2. 数字索引的返回值必须是字符串索引返回值类型的子类型。

```
interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
```

3. 索引签名设置为只读，这样就防止了给索引赋值

### 类类型

1. 强制一个类去符合某种契约
2. 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。

### 类静态部分与实例部分

### 继承接口

1. 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里
2. 一个接口可以继承多个接口

### 混合类型

### 接口继承类

1. 当接口继承了一个类类型时，它会继承类的成员但不包括其实现
2. 当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现
3. 用处：指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系

## 类

### 继承

1. 派生类包含了一个构造函数，它必须调用 super()
2. 在构造函数里访问 this 的属性之前，我们一定要调用 super()

### 公共，私有与受保护的修饰符

1. private 时，它就不能在声明它的类的外部访问
2. protected 成员在派生类中仍然可以访问
3. 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承

### readonly 修饰符

1. readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化

### 参数属性

1.  参数属性可以方便地让我们在一个地方定义并初始化一个成员。

### 存取器

支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。

1. 编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3
2. 只带有 get 不带有 set 的存取器自动被推断为 readonly

### 静态属性

1. 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。

### 抽象类

1. 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化
2. 抽象类可以包含成员的实现细节
3. abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法
4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现

### 构造函数

### 把类当做接口使用

## 函数

### 类型

1. 函数的类型只是由参数类型和返回值组成的

### 推断类型

1.  按上下文归类

### 可选参数和默认参数

1. 在参数名旁使用?实现可选参数的功能

### 剩余参数

1. 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。
2. 在 TypeScript 里，你可以把所有参数收集到一个变量里：

```
function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}
```

### this

1. JavaScript 里，this 的值在函数被调用的时候才会指定
2. 箭头函数能保存函数创建时的 this 值，而不是调用时的值

#### this 参数在回调函数里

1. 库函数的作者要指定 this 的类型......

#### 重载

1. 在定义重载的时候，一定要把最精确的定义放在最前面。

## 泛型

1. 我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。

```
function identity<T>(arg: T): T {
    return arg;
}
```

2. 第一种是，传入所有的参数，包含类型参数
3. 第二种: 利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定 T 的类型

```
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
```

### 泛型类型

### 泛型类

1. 直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型
2. 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。

### 泛型约束

1. 这个接口和 extends 关键字来实现约束;

```
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```

### 在泛型约束中使用类型参数

你可以声明一个类型参数，且它被另一个类型参数所约束

```
function getProperty(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // okay
getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
```

### 在泛型里使用类类型

1. 在 TypeScript 使用泛型创建工厂函数时，需要引用构造函数的类类型
2. 使用原型属性推断并约束构造函数与类实例的关系。
   【注意：】这里有个难懂的点

## 枚举

1.  TypeScript 支持数字的和基于字符串的枚举。

```
enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
```

2. 数字枚举可以被混入到计算过的和常量成员（如下所示）。 但是不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。

### 字符串枚举

1. 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。

### 异构枚举

1. 枚举可以混合字符串和数字成员

### 计算的和常量成员

每个枚举成员都带有一个值，它可以是常量或计算出来的。

1.  枚举成员被当作是常量  
    a. 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0：  
    b. 它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加 1。  
    c. 枚举成员使用 常量枚举表达式初始化。
    d. 常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。

2.  所有其它情况的枚举成员被当作是需要计算得出的值。

### 联合枚举与枚举成员的类型

#### 字面量枚举成员

指不带有初始值的常量枚举成员，或者是值被初始化为

1. 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。首先，枚举成员成为了类型! 另一个变化是枚举类型本身变成了每个枚举成员的联合。

#### 运行时的枚举

#### 反向映射

除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字

```
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

包含了正向映射（ name -> value）和反向映射（ value -> name）  
不会为字符串枚举成员生成反向映射

#### const 枚举

1. 常量枚举通过在枚举上使用 const 修饰符来定义
2. 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。
3. 常量枚举不允许包含计算成员

#### 外部枚举

1. 外部枚举用来描述已经存在的枚举类型的形状
2. 在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。

## 类型推论

### 最佳通用类型

1. 当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型
2. 当候选类型不能使用的时候我们需要明确的指出类型
3. 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型

### 上下文类型

TypeScript 类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。

1. 函数表达式有明确的参数类型注解，上下文类型被忽略。
2. 上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。

### 类型兼容性

1. TypeScript 里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式
2. 基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。
3. typeScript 的结构性子类型是根据 JavaScript 代码的典型写法来设计的

```
interface Named {
    name: string;
}

class Person {
    name: string;
}

let p: Named;
p = new Person(); // Person和Named具有相同的结构
// 在使用基于名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。
```

4. 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。

### 函数参数双向协变

当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。

### 可选参数及剩余参数

比较函数兼容性的时候，可选参数与必须参数是可互换的。

1. 当一个函数有剩余参数时，它被当做无限个可选参数。

### 函数重载

1. 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。

#### 枚举

枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的

#### 类

类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。

1. 类的私有成员和受保护成员:  
   类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。  
   这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。

#### 泛型

1. 类型参数只影响使用其做为类型一部分的结果类型
2. 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 any 比较。 然后用结果类型进行比较

### 高级主题

#### 子类型与赋值

1. 在 TypeScript 里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和 any 来回赋值，以及 enum 和对应数字值之间的来回赋值。

## 高级类型

### 交叉类型

交叉类型是将多个类型合并为一个类型

### 联合类型

联合类型表示一个值可以是几种类型之一。

1. 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。
2. 联合类型适合于那些值可以为不同类型的情况。

### 类型保护与区分类型

1. 要使用类型断言

### 用户自定义的类型保护

1. 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。
2. 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词

```
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

### typeof 类型保护

1. TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。
2. "number"， "string"， "boolean"或 "symbol"

### instanceof 类型保护

instanceof 类型保护是通过构造函数来细化类型的一种方式;instanceof 的右侧要求是一个构造函数，TypeScript 将细化为：

1. 此构造函数的 prototype 属性的类型，如果它的类型不为 any 的话
2. 构造签名所返回的类型的联合

### 可以为 null 的类型

1. TypeScript 具有两种特殊的类型， null 和 undefined，它们分别具有值 null 和 undefined.
2. --strictNullChecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。 你可以使用联合类型明确的包含它们：
3. TypeScript 会把 null 和 undefined 区别对待

### 可选参数和可选属性

1. 使用了 --strictNullChecks，可选参数会被自动地加上 | undefined； 可选属性也会有同样的处理

### 类型保护和类型断言

1. 如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier 的类型里去除了 null 和 undefined

### 类型别名

1. 类型别名会给一个类型起个新名字
2. 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。
3. 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。
4. 类型别名也可以是泛型
5. 类型别名不能出现在声明右侧的任何地方
6. 类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）

```
软件中的对象应该对于扩展是开放的，但是对于修改是封闭的
```

### 字符串字面量类型

1. 字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合
2. 字符串字面量类型还可以用于区分函数重载

### 数字字面量类型

### 枚举成员类型

### 可辨识联合

合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。

1. 具有普通的单例类型属性— 可辨识的特征。
2. 一个类型别名包含了那些类型的联合— 联合。
3. 此属性上的类型保护。

### 完整性检查

当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们

1. 启用 --strictNullChecks 并且指定一个返回值类型
2. 使用 never 类型，编译器用它来进行完整性检查

### 多态的 this 类型

多态的 this 类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded 多态性。

1. 在每个操作之后都返回 this 类型, 由于这个类使用了 this 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变

### 索引类型

通过 索引类型查询和 索引访问操作符

1.  keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T 的结果为 T 上已知的公共属性名的联合。
2.  T\[K\]， 索引访问操作符
3.  确保类型变量 K extends keyof T 就可以了

### 索引类型和字符串索引签名

keyof 和 T[K]与字符串索引签名进行交互

1. 有一个带有字符串索引签名的类型，那么 keyof T 会是 string

### 映射类型

在映射类型里，新类型以相同的形式去转换旧类型里每个属性

1.  你可以令每个属性成为 readonly 类型或可选的

```
interface Person {
   name: string;
   age: number;
}

type Readonly<T> = {
   readonly [P in keyof T]: T[P];
}

type ReadonlyPerson = Readonly<Person>;

```
2. 它的语法与索引签名的语法类型，内部使用了 for .. in。     
a. 类型变量 K，它会依次绑定到每个属性。     
b. 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。      
c. 属性的结果类型。     
3. 通用版本

```
type Nullable<T> = { [P in keyof T]: T[P] | null }
type Partial<T> = { [P in keyof T]?: T[P] }
```
类转换是 同态的，映射只作用于 T的属性而没有其它的       
4. Readonly<T>和 Partial<T>用处不小，因此它们与 Pick和 Record一同被包含进了TypeScript的标准库里：       
5.  Record并不需要输入类型来拷贝属性，所以它不属于同态      
6. 非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符     

### 由映射类型进行推断

1. Exclude<T, U> -- 从T中剔除可以赋值给U的类型。
2.  Extract<T, U> -- 提取T中可以赋值给U的类型。
3. NonNullable<T> -- 从T中剔除null和undefined。
4. ReturnType<T> -- 获取函数返回值类型。
5. InstanceType<T> -- 获取构造函数类型的实例类型。

## Symbols
1. 自ECMAScript 2015起，symbol成为了一种新的原生类型
2. symbol类型的值是通过Symbol构造函数创建的。
3. Symbols是不可改变且唯一的。
4. symbols也可以被用做对象属性的键
5. Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。

```
const getClassNameSymbol = Symbol();

class C {
    [getClassNameSymbol](){
       return "C";
    }
}

let c = new C();
let className = c[getClassNameSymbol](); // "C"
```

### 方法
1. Symbol.hasInstance: 会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例
2. Symbol.isConcatSpreadable: 表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开。
3. Symbol.iterator: 被for-of语句调用。返回对象的默认迭代器
......
4. Symbol.unscopables: 它自己拥有的属性会被with作用域排除在外。

## 迭代器和生成器

### 可迭代性

1. for..in迭代的是对象的 键 的列表，而for..of则迭代对象的键对应的值。
2. for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值


## 模块
“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”

1. 如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）
2. 具有副作用的导入模块     
一些模块会设置一些全局状态供其它模块使用        
```
import "./my-module.js";
```

### 可选的模块加载和其它高级加载场景
1.  如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。
2. typeof关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。

### 模块声明通配符
某些模块加载器如SystemJS 和 AMD支持导入非JavaScript内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。

#### 使用命名空间导入模式当你要导出大量内容的时候

### 模块里不要使用命名空间

### 危险信号
1. 文件的顶层声明是export namespace Foo { ... } （删除Foo并把所有内容向上层移动一层）
2. 文件只有一个export class或export function （考虑使用export default）
3. 多个文件的顶层具有同样的export namespace Foo { （不要以为这些会合并到一个Foo中！）

## 命名空间

## 命名空间和模块

1. 命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。
2.  命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的 &lt;script>标签里。

## 模块解析 (未认证看，需要重新看)

### 相对 vs. 非相对模块导入

1. 相对导入是以/，./或../开头的。
2. 所有其它形式的导入被当作非相对的。
3. 相对导入在解析时是相对于导入它的文件，并且不能解析为一个外部模块声明
4. 非相对模块的导入可以相对于baseUrl或通过下文会讲到的路径映射来进行解析

### 模块解析策略
1. 两种可用的模块解析策略：Node和Classic。

#### 附加的模块解析标记

##### Base URL
1. 命令行中baseUrl的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）
2. ‘tsconfig.json’里的baseUrl属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算）

## 声明合并

### 基础概念
1.  创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 
2. 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 
3. 创建值的声明会创建在JavaScript输出中看到的值。

### 合并接口

合并的机制是把双方的成员放到一个同名的接口里。
1. 接口的非函数的成员应该是唯一的
2. 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载
3. 后面的接口具有更高的优先级
4. 果签名里有一个参数的类型是 单一的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。

### 合并命名空间
1. 对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。
2. 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。
3. 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。

### 命名空间与类和函数和枚举类型合并
1. 命名空间可以与其它类型的声明进行合并。合并结果包含两者的声明类型

#### 合并命名空间和类
这让我们可以表示内部类。


### 非法的合并
TypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 

### 模块扩展
1. 虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们

```
import { Observable } from "./observable";
declare module "./observable" {
    interface Observable<T> {
        map<U>(f: (x: T) => U): Observable<U>;
    }
}
```

### 全局扩展
```
declare global {
    interface Array<T> {
        toObservable(): Observable<T>;
    }
}

```

全局扩展与模块扩展的行为和限制是相同的。

## JSX
1. 给文件一个.tsx扩展名
2. 启用jsx选项
3. 具有三种JSX模式：preserve，react和react-native。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响     
a. preserve模式下生成代码中会保留JSX以供后续的转换操作使用（比如：Babel）。 另外，输出文件会带有.jsx扩展名。        
b. react模式会生成React.createElement，在使用前不需要再进行转换操作了，输出文件的扩展名为.js。     
c. react-native相当于preserve，它也保留了所有的JSX，但是输出文件的扩展名是.js。     

4. 可以通过在命令行里使用--jsx标记或tsconfig.json里的选项来指定模式。

### as操作符

TypeScript在.tsx文件里禁用了使用尖括号的类型断言。

### 类型检查
固有元素与基于值的元素之间的区别:  固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。

#### 固有元素
固有元素使用特殊的接口JSX.IntrinsicElements来查找

```
declare namespace JSX {
    interface IntrinsicElements {
        foo: any
    }
}

<foo />; // 正确
<bar />; // 错误
```

#### 基于值的元素
基于值的元素会简单的在它所在的作用域里按标识符查找。

1. 无状态函数组件 (SFC)
2. 类组件
TypeScript首先会尝试将表达式做为无状态函数组件进行解析。如果解析成功，那么TypeScript就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么TypeScript会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。

#### 无状态函数组件
组件被定义成JavaScript函数，它的第一个参数是props对象
1. 无状态函数组件是简单的JavaScript函数，所以我们还可以利用函数重载

#### 类组件
1. 元素类的类型和元素实例的类型。
2. 如果MyComponent是ES6的类，那么类类型就是类的构造函数和静态部分。 
3. 如果MyComponent是个工厂函数，类类型为这个函数。
4. 一旦建立起了类类型，实例类型由类构造器或调用签名（如果存在的话）的返回值的联合构成

### 属性类型检查
第一步是确定元素属性类型

1. 对于固有元素，这是JSX.IntrinsicElements属性的类型。
2. 对于基于值的元素，它取决于先前确定的在元素实例类型上的某个属性的类型
3. 至于该使用哪个属性来确定类型取决于JSX.ElementAttributesProperty。 它应该使用单一的属性来定义。
4. 如果未指定JSX.ElementAttributesProperty，那么将使用类元素构造函数或SFC调用的第一个参数的类型。
5. 如果一个属性名不是个合法的JS标识符（像data-*属性），并且它没出现在元素属性类型里时不会当做一个错误。

```
var props = { requiredProp: 'bar' };
<foo {...props} />; // 正确

var badProps = {};
<foo {...badProps} />; // 错误
```

### 子孙类型检查
1. 不特殊指定子孙的类型，我们将使用React typings里的默认类型
2.  children类型检查。children是元素属性(attribute)类型的一个特殊属性(property)，子JSXExpression将会被插入到属性里

### JSX结果类型
1. 默认地JSX表达式结果的类型为any
2. 通过指定JSX.Element接口，可以自定义这个类型，
3. 不能够从接口里检索元素，属性或JSX的子元素的类型信息

### 嵌入的表达式
JSX允许你使用{ }标签来内嵌表达式。


### React整合
要想一起使用JSX和React，你应该使用React类型定义。

### 工厂函数
jsx: react编译选项使用的工厂函数是可以配置的。
1. 可以使用jsxFactory命令行选项，
2. 内联的@jsx注释指令在每个文件上设置。

工厂函数的选择同样会影响JSX命名空间的查找(类型检查)     
1. 如果工厂函数使用React.createElement定义（默认），编译器会先检查React.JSX，之后才检查全局的JSX。
2. 如果工厂函数定义为h，那么在检查全局的JSX之前先检查h.JSX。


## 装饰器
1. 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。
2. 要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项：

### 装饰器
装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。
1. 它会在运行时被调用，被装饰的声明信息做为参数传入。

### 装饰器工厂
1. 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。

### 装饰器组合
多个装饰器可以同时应用到一个声明上
1. 当多个装饰器应用于一个声明上，它们求值方式与复合函数相似
2. 由上至下依次对装饰器表达式求值。
3. 求值的结果会被当作函数，由下至上依次调用。

### 装饰器求值
1. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。
2. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。
3. 参数装饰器应用到构造函数。
4. 类装饰器应用到类。

### 类装饰器
1. 类装饰器在类声明之前被声明（紧靠着类声明）
2. 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。
3.  类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）
4. 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。
5. 如果你要返回一个新的构造函数，你必须注意处理好原来的原型链

### 方法装饰器
1. 方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。
2. 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。
3. 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数

```
对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
成员的名字。
成员的属性描述符。(代码输出目标版本小于ES5，属性描述符将会是undefined。)
```

###  访问器装饰器
1.  访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）
2. 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义
3.  TypeScript不允许同时装饰一个成员的get和set访问器, ，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。
4. 在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。

### 属性装饰器
1. 属性装饰器声明在一个属性声明之前（紧靠着属性声明）。

属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：
```
对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
成员的名字。
(属性描述符不会做为参数传入属性装饰器, ，属性描述符只能用来监视类中是否声明了某个名字的属性)
```
### 参数装饰器
1. 参数装饰器声明在一个参数声明之前（紧靠着参数声明）。
2. 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：

```
对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
成员的名字。
参数在函数参数列表中的索引。
```

3.  参数装饰器只能用来监视一个方法的参数是否被传入。

## Mixins
除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式
1. 代码里首先定义了两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。
2. 下面创建一个类，使用implements结合了这两个mixins。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现, 为将要mixin进来的属性方法创建出占位属性
3. 最后，把mixins混入定义的类，完成全部实现部分。

```
applyMixins(SmartObject, [Disposable, Activatable]);

```

4. 最后，创建这个帮助函数，帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。
```
function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        })
    });
}
```

## 三斜线指令
三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。
1. 三斜线指令仅可放在包含它的文件的最顶端
2.  一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。
3.  如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义
4. ///  &lt;reference path="..." />指令，引用告诉编译器在编译过程中要引入的额外的文件。
5. 引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。


## JavaScript文件类型检查
TypeScript 2.3以后的版本支持使用--checkJs对.js文件进行类型检查和错误提示。

1. 你可以通过添加// @ts-nocheck注释来忽略类型检查；
2. 你可以通过去掉--checkJs设置并添加一个// @ts-check注释来选则检查某些.js文件。 

### 用JSDoc类型表示类型信息

### 属性的推断来自于类内的赋值语句
属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是undefined或null
1. 如果一个属性从没在类内设置过，它们会被当成未知的
2. 如果类的属性只是读取用的，那么就在构造函数里用JSDoc声明它的类型。
3. 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：

### 构造函数等同于类
ES2015以前，Javascript使用构造函数代替类。

### 支持CommonJS模块
在.js文件里，TypeScript能识别出CommonJS模块。 对exports和module.exports的赋值被识别为导出声明。

### 类，函数和对象字面量是命名空间
.js文件里的类是命名空间。 它可以用于嵌套类

### 对象字面量是开放的
.ts文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在.js文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。

### null，undefined，和空数组的类型是any或any[]

### 函数参数是默认可选的

### 使用JSDoc注解的函数会被从这条规则里移除。 使用JSDoc可选参数语法来表示可选性

### 由arguments推断出的var-args参数声明
如果一个函数的函数体内有对arguments的引用，那么这个函数会隐式地被认为具有一个var-arg参数

### 未指定的类型参数默认为any
由于JavaScript里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为any。

#### 在extends语句中：
使用JSDoc的@augments来明确地指定类型。

#### 在JSDoc引用中：
JSDoc里未指定的类型参数默认为any：

####  在函数调用中
泛型函数的调用使用arguments来推断泛型参数。

### 支持的JSDoc

#### @type
可以使用@type标记并引用一个类型名称

```
/**
 * @type {string}
 */
var s;

/** @type {Window} */
var win;

/** @type {PromiseLike<string>} */
var promisedString;
```

##### 转换
TypeScript借鉴了Closure里的转换语法。 在括号表达式前面使用@type标记，可以将一种类型转换成另一种类型

##### 导入类型
可以使用导入类型从其它文件中导入声明。 这个语法是TypeScript特有的，与JSDoc标准不同：

#### @param和@returns

@param语法和@type相同，但增加了一个参数名。 使用[]可以把参数声明为可选的：

#### @typedef, @callback, 和 @param
1. @typedef可以用来声明复杂类型。 和@param类似的语法。
2. @callback与@typedef相似，但它指定函数类型而不是对象类型：

#### @template
1. 使用@template声明泛型：
2. 用逗号或多个标记来声明多个类型参数：
3. 还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：

#### @constructor
1. 编译器通过this属性的赋值来推断构造函数，
2. 你可以让检查更严格提示更友好，你可以添加一个@constructor标记：

#### @this
1. 编译器通常可以通过上下文来推断出this的类型
2. 你可以使用@this来明确指定它的类型：

#### @extends
1. 注意@extends只作用于类。当前，无法实现构造函数继承类的情况。

#### @enum
1. @enum标记允许你创建一个对象字面量，它的成员都有确定的类型。
2. 不同于JavaScript里大多数的对象字面量，它不允许添加额外成员。
3. 不同于TypeScript的枚举，@enum可以是任何类型：

### 已知不支持的模式
1. 在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。
2. 对象字面量属性上的=后缀不能指定这个属性是可选的：
3. Nullable类型只在启用了strictNullChecks检查时才启作用：
4. Non-nullable类型没有意义，以其原类型对待：